# A second connection with machine learning {#sec-2nd-connection-ML}
{{< include macros.qmd >}}
{{< include macros_prob_inference.qmd >}}

In [chapter @sec-1st-connection-ML] we made a first *tentative* connection between the notions about probability explored until then, and notions from machine learning. We considered the possibility that a machine-learning algorithm is like an agent that has some [built-in background information (corresponding to the algorithm's architecture)]{.yellow}, has received [pieces of information (corresponding to the data about perfectly known instances of the task)]{.green}, and is assessing a [not-previously known piece of information (the outcome in a new task instance)]{.red}:

$$
\P(\underbracket[0ex]{\red\se{D}_{N+1}}_{\mathclap{\red\text{outcome?}}} \| 
\green\underbracket[0ex]{\se{D}_N \land \dotsb \land \se{D}_2 \land \se{D}_1}_{\mathclap{\green\text{training data?}}} 
\black\land \underbracket[0ex]{\yellow\yI}_{\mathrlap{\yellow\uparrow\ \text{architecture?}}})
$$

The correspondence about [training data]{.green} and [architecture]{.yellow} seem somewhat convincing, the one about [outcome]{.red} will need more exploration, because it seems to involve some decision process -- and we haven't fully explored the machinery of decision-making yet.

Having introduced the notion of quantity in the latest chapters [-@sec-data-types-basic] and [-@sec-data-types-multi], we recognize that training data about a task instance concern some quantity and its value, so they can be expressed by a sentence like $D_i\mo d_i$, where

- $i$ is the instance: $1,2,\dotsc,N$
- $D_i$ describes the kind of data at instance $i$, say "128 × 128 image with 24-bit colour depth"
- $d_i$ is the value of the data at instance $i$, say the one at the margin

:::{.column-margin}
![](muppet.jpg){width=128px}
:::

And similarly for the outcome of a new task instance where the algorithm is applied for real, which we consider as instance $N+1$. So we can rewrite the correspondence above as follows:

$$
\P(\underbracket[0ex]{\red D_{N+1} \mo d_{N+1}}_{\mathclap{\red\text{outcome?}}} \| 
\green\underbracket[0ex]{ D_N \mo d_N \and \dotsb \and  D_2 \mo d_2 \and  D_1 \mo d_1}_{\mathclap{\green\text{training data?}}} 
\black\and \underbracket[0ex]{\yellow\yI}_{\mathrlap{\yellow\uparrow\ \text{architecture?}}})
$$

Let's extend this tentative connection even further.

\

Machine-learning textbooks usually make a distinction between "supervised learning" and "unsupervised learning". Unfortunately the explanation given for this distinction is sometimes misleading:

- {{< fa meh-rolling-eyes >}}\ \ Some books say that in supervised learning the algorithm "learns a functional relationship between some kind of input and some kind of output". This is usually *not* true: in the vast majority of applications there isn't any *functional* relationship between input and output at all; at most only a *statistical* or *probabilistic* one. This is clear from the fact that two training datapoints can have identical inputs but different outputs; and you remember from Calculus I that we can't speak of a function in this case. It's unclear how something that doesn't exist can be learned.

    Books that give this kind of explanation are unfortunately oversimplifying things, to the point of being incorrect^[Paraphrasing [M. W. Zemansky](https://hvl.instructure.com/courses/25074/modules/items/679142):\
	*"Teaching machine learning\
	Is as easy as a song:\
	You think you make it simpler\
	When you make it slightly wrong!"*]. The algorithm is actually doing something more complex -- which we shall analyse in detail later.

- {{< fa meh >}}\ \ Yet other books say that the distinction rests in the kind of data used: "input-output" pairs for supervised learning, and only "inputs" for unsupervised learning. It's good that this description doesn't mention "functions", but it is still unsatisfactory, because it confuses the means with the purpose. It's a little like saying that the difference between car and aeroplane is that the latter has wings. Sure -- but *why?* This description misses the essential difference between these two means of transportation: they operate through different material media and exploit different kinds of physics; that's why the second has wings.

    From this point of view, the terms "supervised learning" and "unsupervised learning" are somewhat unsatisfactory, suffering from the same drawback.

- {{< fa smile >}}\ \ More enlightening books explain that the distinction rests in what the algorithm needs for each new application: in supervised learning, it uses features -- that is, additional information -- available at each new application instance; whereas in unsupervised learning it doesn't: no new instance-dependent information is given.

    From this point of view, we also see that the distinction between "supervised" and "unsupervised" becomes less sharp: we can imagine to increase the information that's used at each new instance from zero ("unsupervised") to larger and larger amounts ("supervised").


Going back to our tentative correspondence with inference and decision-making agents, we see a strong similarity between unsupervised & supervised learning and two kinds of inference:

- In the unsupervised case, even if the quantities ${\green D_1}, {\green D_2}, {\green \dotsc}, {\green D_N}$  in the known instances and in the new instance ${\red D_{N+1}}$ might consist of joint or complex quantities ([chapter @sec-data-types-multi]), we are not interested in their possible decomposition into component quantities. So we still have the tentative connection above:

    $$
    \P(\underbracket[0ex]{\red D_{N+1} \mo d_{N+1}}_{\mathclap{\red\text{outcome?}}} \| 
    \green\underbracket[0ex]{ D_N \mo d_N \and \dotsb \and  D_2 \mo d_2 \and  D_1 \mo d_1}_{\mathclap{\green\text{training data?}}} 
    \black\and \underbracket[0ex]{\yellow\yI}_{\mathrlap{\yellow\uparrow\ \text{architecture?}}})
    $$

    For example, the agent has been given information about a collection of images, and then tries to guess what the next image could be.


- In the supervised case, the quantities in the known instances and in the new application are joint quantities: ${\green D_1} = ({\green Y_1}, {\green X_1}), {\green\dotsc}$ and ${\red D_{N+1}} = ({\red Y_{N+1}}, {\red X_{N+1}})$, and we are interested in the $X$ and $Y$ component quantities separately. For instance, the $X$-quantity could be an image, as in the example above, and the $Y$-quantity could be a label with domain $\set{\cat{Muppet}, \cat{non-Muppet}}$. The reason we make this separation is that, upon applying the algorithm in a new task instance, *one of these component quantities*, say $\red X_{N+1}$, *can actually be observed by the agent*; so it is known. It's the other component quantity, $\red Y_{N+1}$, that the agent is uncertain about. The agent therefore needs to draw the following inference:

    $$
    \P\bigl(
	{\red Y_{N+1} \mo y_{N+1}}
	\|[\big] 
	{\red X_{N+1} \mo x_{N+1}}\, \and\,
    \green Y_N \mo y_N \and X_N \mo x_N \and
	\dotsb \and 
	Y_1 \mo y_1 \and X_1 \mo x_1 
    \black\and {\yellow\yI} \bigr)
    $$




